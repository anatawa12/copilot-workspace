name: Automated Rebase

on:
  workflow_call:
    inputs:
      branch:
        description: 'Target branch to rebase (defaults to current branch)'
        required: false
        type: string
        default: ''
    secrets:
      REBASE_TOKEN:
        description: 'Custom GitHub token for authentication (if not provided, uses GITHUB_TOKEN)'
        required: false

permissions:
  contents: write

jobs:
  rebase:
    name: Perform Automated Rebase
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.REBASE_TOKEN || secrets.GITHUB_TOKEN }}
      
      - name: Check if rebase config exists
        id: check-file
        run: |
          if [ -f ".github/rebase-config.yml" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Rebase config file found"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No rebase config file found"
          fi
      
      - name: Get author and configure Git
        if: steps.check-file.outputs.exists == 'true'
        run: |
          # Get the author of the most recent commit that modified .github/rebase-config.yml
          AUTHOR_NAME=$(git log -1 --pretty=format:'%an' -- .github/rebase-config.yml)
          AUTHOR_EMAIL=$(git log -1 --pretty=format:'%ae' -- .github/rebase-config.yml)
          echo "Author: ${AUTHOR_NAME} <${AUTHOR_EMAIL}>"
          
          # Configure Git with the author information
          git config user.name "$AUTHOR_NAME"
          git config user.email "$AUTHOR_EMAIL"
      
      - name: Parse rebase config
        id: parse-config
        if: steps.check-file.outputs.exists == 'true'
        shell: bash
        run: |
          echo "Parsing rebase config file..."
          cat .github/rebase-config.yml
          
          # Use yq to parse YAML safely
          if ! command -v yq &> /dev/null; then
            echo "Installing yq..."
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi
          
          # Parse base commit
          BASE_COMMIT=$(yq eval '.base_commit' .github/rebase-config.yml)
          echo "base_commit=${BASE_COMMIT}" >> $GITHUB_OUTPUT
          
          # Parse operations and convert to JSON for shell processing
          OPERATIONS=$(yq eval '.operations' -o=json .github/rebase-config.yml)
          echo "operations<<EOF" >> $GITHUB_OUTPUT
          echo "$OPERATIONS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "Base commit: $BASE_COMMIT"
          echo "Operations: $OPERATIONS"
          
          # Remove the rebase config file now that we've parsed it
          # This prevents it from being included in any rebased commits
          echo "Removing rebase config file to prevent it from being included in rebased commits..."
          rm .github/rebase-config.yml
          echo "Rebase config file removed"
      
      - name: Perform rebase operations
        if: steps.check-file.outputs.exists == 'true'
        env:
          BASE_COMMIT: ${{ steps.parse-config.outputs.base_commit }}
          OPERATIONS: ${{ steps.parse-config.outputs.operations }}
        shell: bash
        run: |
          echo "Starting rebase from commit: $BASE_COMMIT"
          echo "Operations to perform: $OPERATIONS"
          
          # Function to perform cherry-pick with conflict resolution
          cherry_pick_with_conflict_resolution() {
            local commit_hash="$1"
            local no_commit_flag="$2"
            
            local cherry_pick_cmd="git cherry-pick --allow-empty"
            if [ "$no_commit_flag" = "true" ]; then
              cherry_pick_cmd="$cherry_pick_cmd --no-commit"
            fi
            
            if ! $cherry_pick_cmd "$commit_hash"; then
              # Check if this is an empty commit error with --no-commit
              if [ "$no_commit_flag" = "true" ] && git status --porcelain | wc -l | grep -q "^0$"; then
                echo "Handling empty commit with --no-commit: nothing staged, which is expected for empty commits"
                # For empty commits with --no-commit, Git fails but we can continue since nothing needs to be staged
                git cherry-pick --skip 2>/dev/null || true
                return 0
              # Check if this is a delete-edit conflict for rebase config file
              elif git status --porcelain | grep -q "^DU \.github/rebase-config\.yml$"; then
                echo "Resolving delete-edit conflict for rebase config file (choosing deletion)"
                git rm .github/rebase-config.yml 2>/dev/null || true
                rm -f .github/rebase-config.yml
                
                if [ "$no_commit_flag" != "true" ]; then
                  git cherry-pick --continue
                fi
                # For --no-commit, the changes are already staged (minus the config file we just removed)
              else
                echo "Error: Failed to cherry-pick commit $commit_hash (non-rebase-config conflict)"
                git cherry-pick --abort 2>/dev/null || true
                return 1
              fi
            fi
            return 0
          }
          
          # Function to remove rebase config file changes
          remove_rebase_config_changes() {
            local from_location="$1"  # "staging", "committed", or "both"
            
            case "$from_location" in
              "staging")
                if git diff --cached --name-only | grep -q "^\.github/rebase-config\.yml$"; then
                  echo "Removing rebase config file changes from staging area"
                  git reset HEAD .github/rebase-config.yml 2>/dev/null || true
                  rm -f .github/rebase-config.yml
                fi
                ;;
              "committed")
                if git show --name-only HEAD | grep -q "^\.github/rebase-config\.yml$"; then
                  echo "Removing rebase config file changes from committed changes"
                  git rm --cached .github/rebase-config.yml 2>/dev/null || true
                  rm -f .github/rebase-config.yml
                  git commit --amend --no-edit --allow-empty
                fi
                ;;
              "both")
                remove_rebase_config_changes "staging"
                remove_rebase_config_changes "committed"
                ;;
            esac
          }
          
          # Function to commit with original metadata
          commit_with_original_metadata() {
            local commit_hash="$1"
            local custom_message="$2"
            local is_amend="$3"
            
            # Get commit details for proper attribution
            local original_author_name=$(git log -1 --pretty=format:'%an' "$commit_hash")
            local original_author_email=$(git log -1 --pretty=format:'%ae' "$commit_hash")
            local original_author_date=$(git log -1 --pretty=format:'%ad' "$commit_hash")
            
            local commit_cmd="git commit --allow-empty"
            if [ "$is_amend" = "true" ]; then
              commit_cmd="$commit_cmd --amend"
            fi
            
            if [ -n "$custom_message" ]; then
              $commit_cmd --author="$original_author_name <$original_author_email>" --date="$original_author_date" -m "$custom_message"
            else
              local original_message=$(git log -1 --pretty=format:'%B' "$commit_hash")
              $commit_cmd --author="$original_author_name <$original_author_email>" --date="$original_author_date" -m "$original_message"
            fi
          }
          
          # Validate base commit exists
          if ! git rev-parse --verify "$BASE_COMMIT" >/dev/null 2>&1; then
            echo "Error: Base commit $BASE_COMMIT does not exist"
            exit 1
          fi
          
          # Parse operations using jq for safe JSON handling
          OPERATION_COUNT=$(echo "$OPERATIONS" | jq '. | length')
          echo "Number of operations: $OPERATION_COUNT"
          
          if [ "$OPERATION_COUNT" -eq 0 ]; then
            echo "No operations to perform"
            exit 0
          fi
          
          # Create backup branch
          CURRENT_BRANCH=$(git branch --show-current)
          BACKUP_BRANCH="backup-before-rebase-$(date +%s)"
          git branch "$BACKUP_BRANCH" HEAD
          echo "Created backup branch: $BACKUP_BRANCH"
          
          # Reset to base commit
          git reset --hard "$BASE_COMMIT"
          
          # Process each operation
          for ((i=0; i<OPERATION_COUNT; i++)); do
            OPERATION=$(echo "$OPERATIONS" | jq -r ".[$i]")
            ACTION=$(echo "$OPERATION" | jq -r '.action')
            COMMIT_HASH=$(echo "$OPERATION" | jq -r '.commit')
            MESSAGE=$(echo "$OPERATION" | jq -r '.message // empty')
            
            echo "Processing operation $((i+1))/$OPERATION_COUNT: $ACTION $COMMIT_HASH"
            
            # Validate commit exists
            if ! git rev-parse --verify "$COMMIT_HASH" >/dev/null 2>&1; then
              echo "Error: Commit $COMMIT_HASH does not exist"
              echo "Restoring from backup branch $BACKUP_BRANCH"
              git reset --hard "$BACKUP_BRANCH"
              git branch -D "$BACKUP_BRANCH"
              exit 1
            fi
            
            case "$ACTION" in
              "pick")
                echo "Picking commit $COMMIT_HASH"
                # Cherry-pick without commit first
                if ! cherry_pick_with_conflict_resolution "$COMMIT_HASH" "true"; then
                  git reset --hard "$BACKUP_BRANCH"
                  git branch -D "$BACKUP_BRANCH"
                  exit 1
                fi
                
                # Remove rebase config changes from staging
                remove_rebase_config_changes "staging"
                
                # Commit with original commit message, author, and time
                commit_with_original_metadata "$COMMIT_HASH" "" "false"
                ;;
              "squash")
                echo "Squashing commit $COMMIT_HASH"
                # Cherry-pick without commit
                if ! cherry_pick_with_conflict_resolution "$COMMIT_HASH" "true"; then
                  git reset --hard "$BACKUP_BRANCH"
                  git branch -D "$BACKUP_BRANCH"
                  exit 1
                fi
                
                # Remove rebase config changes from staging
                remove_rebase_config_changes "staging"
                
                # If this is not the first operation, amend the previous commit
                if [ $i -gt 0 ]; then
                  commit_with_original_metadata "$COMMIT_HASH" "$MESSAGE" "true"
                else
                  # First operation, create new commit
                  commit_with_original_metadata "$COMMIT_HASH" "$MESSAGE" "false"
                fi
                ;;
              *)
                echo "Error: Unknown action '$ACTION'"
                git reset --hard "$BACKUP_BRANCH"
                git branch -D "$BACKUP_BRANCH"
                exit 1
                ;;
            esac
          done
          
          echo "All rebase operations completed successfully"
          
          # Clean up backup branch
          git branch -D "$BACKUP_BRANCH"
      
      - name: Force push changes
        if: steps.check-file.outputs.exists == 'true'
        env:
          TARGET_BRANCH: ${{ inputs.branch }}
        shell: bash
        run: |
          if [ -z "$TARGET_BRANCH" ]; then
            TARGET_BRANCH=$(git branch --show-current)
          fi
          
          echo "Force pushing to branch: $TARGET_BRANCH"
          git push --force-with-lease origin "$TARGET_BRANCH"
