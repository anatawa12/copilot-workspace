name: Automated Rebase

on:
  workflow_call:
    inputs:
      branch:
        description: 'Target branch to rebase (defaults to current branch)'
        required: false
        type: string
        default: ''
  push:
    paths:
      - '.github/rebase-todo'

permissions:
  contents: write

jobs:
  rebase:
    name: Perform Automated Rebase
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Check if rebase-todo exists
        id: check-file
        run: |
          if [ -f ".github/rebase-todo" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Rebase todo file found"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No rebase todo file found"
          fi
      
      - name: Get rebase-todo file author
        id: get-author
        if: steps.check-file.outputs.exists == 'true'
        run: |
          # Get the author of the most recent commit that modified .github/rebase-todo
          AUTHOR_NAME=$(git log -1 --pretty=format:'%an' -- .github/rebase-todo)
          AUTHOR_EMAIL=$(git log -1 --pretty=format:'%ae' -- .github/rebase-todo)
          echo "name=${AUTHOR_NAME}" >> $GITHUB_OUTPUT
          echo "email=${AUTHOR_EMAIL}" >> $GITHUB_OUTPUT
          echo "Author: ${AUTHOR_NAME} <${AUTHOR_EMAIL}>"
      
      - name: Configure Git
        if: steps.check-file.outputs.exists == 'true'
        run: |
          git config user.name "${{ steps.get-author.outputs.name }}"
          git config user.email "${{ steps.get-author.outputs.email }}"
      
      - name: Parse rebase-todo file
        id: parse-todo
        if: steps.check-file.outputs.exists == 'true'
        run: |
          echo "Parsing rebase-todo file..."
          cat .github/rebase-todo
          
          # Parse the rebase-todo file
          python3 << 'EOF'
          import json
          import os
          import sys
          
          def parse_rebase_todo():
              with open('.github/rebase-todo', 'r') as f:
                  lines = [line.strip() for line in f.readlines() if line.strip() and not line.startswith('#')]
              
              if not lines:
                  print("Error: Empty rebase-todo file")
                  sys.exit(1)
              
              # First line should be the base commit
              base_commit = lines[0]
              
              # Remaining lines are commit operations
              operations = []
              i = 1
              while i < len(lines):
                  line = lines[i]
                  if line.startswith('squash ') or line.startswith('s '):
                      # Format: squash <commit-hash> [new-message]
                      parts = line.split(' ', 2)
                      action = 'squash'
                      commit_hash = parts[1]
                      new_message = parts[2] if len(parts) > 2 else ''
                      operations.append({
                          'action': action,
                          'commit': commit_hash,
                          'message': new_message
                      })
                  elif line.startswith('pick ') or line.startswith('p '):
                      # Format: pick <commit-hash>
                      parts = line.split(' ', 2)
                      action = 'pick'
                      commit_hash = parts[1]
                      operations.append({
                          'action': action,
                          'commit': commit_hash,
                          'message': ''
                      })
                  i += 1
              
              result = {
                  'base_commit': base_commit,
                  'operations': operations
              }
              
              # Output for GitHub Actions
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"base_commit={base_commit}\n")
                  f.write(f"operations={json.dumps(operations)}\n")
              
              print(f"Base commit: {base_commit}")
              print(f"Operations: {json.dumps(operations, indent=2)}")
              
              return result
          
          parse_rebase_todo()
          EOF
      
      - name: Perform rebase operations
        if: steps.check-file.outputs.exists == 'true'
        run: |
          BASE_COMMIT="${{ steps.parse-todo.outputs.base_commit }}"
          OPERATIONS='${{ steps.parse-todo.outputs.operations }}'
          
          echo "Starting rebase from commit: $BASE_COMMIT"
          echo "Operations to perform: $OPERATIONS"
          
          # Create a temporary rebase script
          python3 << 'EOF'
          import json
          import subprocess
          import sys
          import os
          import tempfile
          
          def run_git_command(cmd, check=True):
              """Run a git command and return the result"""
              print(f"Running: {' '.join(cmd)}")
              result = subprocess.run(cmd, capture_output=True, text=True, check=check)
              if result.stdout:
                  print(f"Output: {result.stdout.strip()}")
              if result.stderr:
                  print(f"Error: {result.stderr.strip()}")
              return result
          
          base_commit = os.environ['BASE_COMMIT']
          operations = json.loads(os.environ['OPERATIONS'])
          
          print(f"Base commit: {base_commit}")
          print(f"Number of operations: {len(operations)}")
          
          # Create interactive rebase todo script
          rebase_script_lines = []
          
          for op in operations:
              action = op['action']
              commit = op['commit']
              message = op.get('message', '')
              
              if action == 'pick':
                  rebase_script_lines.append(f"pick {commit}")
              elif action == 'squash':
                  rebase_script_lines.append(f"squash {commit}")
          
          # Write the rebase script to a temporary file
          with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
              for line in rebase_script_lines:
                  f.write(line + '\n')
              rebase_script_path = f.name
          
          print(f"Created rebase script at: {rebase_script_path}")
          with open(rebase_script_path, 'r') as f:
              print("Rebase script contents:")
              print(f.read())
          
          try:
              # Set the GIT_SEQUENCE_EDITOR to use our script
              env = os.environ.copy()
              env['GIT_SEQUENCE_EDITOR'] = f'cp {rebase_script_path}'
              
              # Perform the interactive rebase
              result = subprocess.run(['git', 'rebase', '-i', base_commit], 
                                    env=env, capture_output=True, text=True, check=False)
              
              if result.returncode != 0:
                  print(f"Rebase failed with return code: {result.returncode}")
                  print(f"stdout: {result.stdout}")
                  print(f"stderr: {result.stderr}")
                  
                  # Try to abort the rebase
                  subprocess.run(['git', 'rebase', '--abort'], check=False)
                  sys.exit(1)
              
              print("Rebase completed successfully")
              
              # Now handle custom commit messages for squashed commits
              for op in operations:
                  if op['action'] == 'squash' and op.get('message'):
                      # We'll use git commit --amend for the final squashed commit
                      print(f"Updating commit message to: {op['message']}")
                      try:
                          subprocess.run(['git', 'commit', '--amend', '-m', op['message']], check=True)
                      except subprocess.CalledProcessError as e:
                          print(f"Warning: Could not update commit message: {e}")
              
          finally:
              # Clean up temporary file
              if os.path.exists(rebase_script_path):
                  os.unlink(rebase_script_path)
          
          print("All rebase operations completed successfully")
          EOF
      
      - name: Force push changes
        if: steps.check-file.outputs.exists == 'true'
        run: |
          CURRENT_BRANCH="${{ inputs.branch }}"
          if [ -z "$CURRENT_BRANCH" ]; then
            CURRENT_BRANCH=$(git branch --show-current)
          fi
          
          echo "Force pushing to branch: $CURRENT_BRANCH"
          git push --force-with-lease origin "$CURRENT_BRANCH"
      
      - name: Clean up rebase-todo file
        if: steps.check-file.outputs.exists == 'true'
        run: |
          echo "Removing rebase-todo file after successful rebase"
          git rm .github/rebase-todo
          git commit -m "Remove rebase-todo file after successful rebase"
          git push origin $(git branch --show-current)